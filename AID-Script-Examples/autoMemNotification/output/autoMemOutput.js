// Displays a pop- up message with auto-generated entries to quickly read through and discard them with the numeric, attached values.
// We want to redesign it to be a 'catch and release' mechanic. Assemble the list, store corresponding data and present it until it is time to release.
// It has to be somewhat adaptive by removing already deleted entries. Input modifier should signal for the output to do its processing, not handle it itself.
const getHistoryType = (turns) => { return history.slice(turns).flatMap(elem => elem["type"]).join() }
const modifier = (text) =>
{
    if (worldEntries.length != state.copyWorldEntries.length && !state.blockOutput) // Detect and assemble the new auto-generated entries into an array that is present on consecutive, invalidated turns.
    {
        state.manageEntries = [] // Create a clean slate for when rebuilding the list.
        const newEntriesCount = (worldEntries.length - state.copyWorldEntries.length) // For indexing, find out by how many entries they deviate from each other.
        const newEntries = worldEntries.slice(-newEntriesCount) // Extract the latest, new auto-generated entries from the list.
        // Push the auto-generated entries into a persistent state, manageEntries, then pass the control over to the manageEntries block. 
        newEntries.forEach(entry => {if (entry["autoGenerated"]) {state.manageEntries.push(entry)}}) // Filter out player-created entries. 
    }
    
    if (state.manageEntries.length > 0) // Once and if a list has been assembled, present the array until it's emptied or the user continues.
    {
        state.message = `Input the corresponding value to delete the entry.`
        let assignNumber = 1;
        state.manageEntries.forEach(entry => 
        {
            state.message += `\n[${assignNumber})] [Keys: ${entry["keys"]}] [Entry: ${entry["entry"]}]`; // Inform the player of the new entry with its keys and entry content.
            assignNumber++; // Increment the value.
        })
    }

    //if (getHistoryType(-1) == 'continue' && state.blockOutput && !(/[0-9]+ ?/gi.test(text))) {state.blockOutput = false; delete state.message; state.manageEntries = []} // Permit a continue action to unblock.
    if (state.blockOutput) {return {text: ""}} // Empty the output until the input releases the condition.
    return {text}
}
modifier(text)