// Displays a pop- up message with auto-generated entries to quickly read through and discard them with the numeric, attached values.
const modifier = (text) =>
{
    if (!state.blockOutput) {delete state.message} // Clear the messages, only display them if neccessary.

    if (worldEntries && worldEntries.length != state.copyWorldEntries.length) // Process the following if the worldEntries has been manipulated with additional or fewer entries (values are too sporradic)
    {
        state.message = `Input the corresponding value to delete the entry.`
        const newEntriesCount = (worldEntries.length - state.copyWorldEntries.length) // For indexing, find out by how many entries they deviate from each other.
        const newEntries = worldEntries.slice(-newEntriesCount) // Extract the latest, new auto-generated entries from the list.

        let assignNumber = 1;

        newEntries.forEach(entry => // Loop through the entries, assign a numerical value and present it in state.message if it's auto-generated.
            {
                if (entry["autoGenerated"]) // Filter out player-created entries.
                {
                    state.message += `\n[${assignNumber})] [Keys: ${entry["keys"]}] [Entry: ${entry["entry"]}]`; // Inform the player of the new entry with its keys and entry content.
                    state.manageEntries.push(worldEntries.indexOf(entry)) // Store the index of the entry and the numerical value used to signal its deletion.
                    assignNumber++; // Increment the value.
                }
            })
        state.copyWorldEntries = worldEntries; // Refresh the copy to align it for the next match.
    }
    
    if (state.blockOutput) {state.blockOutput = false; return {text: ""}} // Prevent an output to quickly process.

    return {text}
}
modifier(text)